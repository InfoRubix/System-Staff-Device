/**
 * Professional PDF Generation Service
 * Provides consistent, high-quality PDF exports across the application
 */

class PDFService {
  constructor() {
    this.brandColors = {
      primary: [25, 118, 210], // #1976d2
      secondary: [100, 100, 100], // Gray
      success: [46, 125, 50], // Green
      warning: [237, 108, 2], // Orange
      error: [211, 47, 47], // Red
      light: [245, 245, 245], // Light gray
      border: [200, 200, 200] // Border gray
    };
  }

  /**
   * Creates a professional PDF with table data
   * @param {Object} options - Configuration options
   * @returns {Promise<boolean>} - Success status
   */
  async createProfessionalPDF(options) {
    try {
      const {
        title,
        data,
        columns,
        filters = {},
        orientation = 'landscape',
        filename,
        additionalInfo = {}
      } = options;

      // Dynamic import for jsPDF
      const { jsPDF } = await import('jspdf');
      const doc = new jsPDF(
        orientation === 'landscape' ? 'l' : 'p',
        'mm',
        'a4'
      );

      let startY = this.addHeader(doc, title, filters, additionalInfo);

      if (data.length === 0) {
        this.addEmptyState(doc, startY);
      } else {
        this.addProfessionalTable(doc, data, columns, startY);
      }

      // Save the PDF
      const sanitizedFilename = this.sanitizeFilename(filename);
      doc.save(sanitizedFilename);

      return true;
    } catch (error) {
      console.error('PDF generation failed:', error);
      return false;
    }
  }

  /**
   * Adds professional header to PDF
   */
  addHeader(doc, title, filters, additionalInfo) {
    // Title
    doc.setFontSize(24);
    doc.setTextColor(...this.brandColors.primary);
    doc.text(title, 20, 25);

    // Date and additional info
    doc.setFontSize(11);
    doc.setTextColor(...this.brandColors.secondary);
    let yPos = 40;

    doc.text(`Generated on: ${new Date().toLocaleDateString('en-GB')} at ${new Date().toLocaleTimeString('en-GB')}`, 20, yPos);
    yPos += 6;

    // Company info if available
    if (additionalInfo.company) {
      doc.text(`Company: ${additionalInfo.company}`, 20, yPos);
      yPos += 6;
    }

    // Generated by info if available
    if (additionalInfo.generatedBy) {
      doc.text(`Generated by: ${additionalInfo.generatedBy}`, 20, yPos);
      yPos += 6;
    }

    yPos += 5;

    // Filters section
    if (Object.keys(filters).length > 0) {
      doc.setFontSize(12);
      doc.setTextColor(0, 0, 0);

      const filterTexts = [];
      Object.entries(filters).forEach(([key, value]) => {
        if (value) {
          filterTexts.push(`${key}: ${value}`);
        }
      });

      if (filterTexts.length > 0) {
        doc.text(`Applied Filters: ${filterTexts.join(', ')}`, 20, yPos);
        yPos += 10;
      }
    }

    // Data count
    if (additionalInfo.totalCount !== undefined) {
      doc.setFontSize(11);
      doc.setTextColor(...this.brandColors.secondary);
      doc.text(`Total Records: ${additionalInfo.totalCount}`, 20, yPos);
      yPos += 15;
    } else {
      yPos += 10;
    }

    return yPos;
  }

  /**
   * Adds professional table with proper formatting
   */
  addProfessionalTable(doc, data, columns, startY) {
    const tableWidth = doc.internal.pageSize.width - 40; // 20mm margins on each side
    const columnWidths = this.calculateColumnWidths(columns, tableWidth);
    const baseRowHeight = 10;

    let yPos = startY;

    // Draw table headers
    this.drawTableHeader(doc, columns, columnWidths, yPos, baseRowHeight);
    yPos += baseRowHeight;

    // Draw table rows
    data.forEach((row, rowIndex) => {
      // Calculate required height for this row (check for long text)
      let maxLines = 1;
      columns.forEach((column, colIndex) => {
        const value = this.getColumnValue(row, column);
        const maxWidth = columnWidths[colIndex] - 4; // Account for padding
        const lines = doc.splitTextToSize(value, maxWidth);
        maxLines = Math.max(maxLines, lines.length);
      });

      const rowHeight = baseRowHeight * maxLines;

      // Check for page break
      if (yPos + rowHeight > doc.internal.pageSize.height - 30) {
        doc.addPage();
        yPos = 20;
        // Redraw headers on new page
        this.drawTableHeader(doc, columns, columnWidths, yPos, baseRowHeight);
        yPos += baseRowHeight;
      }

      // Alternate row colors
      if (rowIndex % 2 === 1) {
        doc.setFillColor(...this.brandColors.light);
        doc.rect(20, yPos, tableWidth, rowHeight, 'F');
      }

      // Draw row data with proper text wrapping
      this.drawTableRowWithWrapping(doc, row, columns, columnWidths, yPos, rowHeight, baseRowHeight);
      yPos += rowHeight;
    });

    // Draw table borders (simplified for multi-line support)
    this.drawTableBordersSimple(doc, columns, columnWidths, startY, yPos);
  }

  /**
   * Draws table header with branding
   */
  drawTableHeader(doc, columns, columnWidths, yPos, rowHeight) {
    const tableWidth = columnWidths.reduce((sum, width) => sum + width, 0);

    // Header background
    doc.setFillColor(...this.brandColors.primary);
    doc.rect(20, yPos, tableWidth, rowHeight, 'F');

    // Header text
    doc.setTextColor(255, 255, 255);
    doc.setFontSize(11);
    doc.setFont(undefined, 'bold');

    let xPos = 20;
    columns.forEach((column, index) => {
      const text = this.truncateText(column.header, columnWidths[index]);
      doc.text(text, xPos + 2, yPos + 6);
      xPos += columnWidths[index];
    });
  }

  /**
   * Draws table row data with text wrapping support
   */
  drawTableRowWithWrapping(doc, row, columns, columnWidths, yPos, rowHeight, baseRowHeight) {
    doc.setTextColor(0, 0, 0);
    doc.setFont(undefined, 'normal');
    doc.setFontSize(10);

    let xPos = 20;
    columns.forEach((column, index) => {
      const value = this.getColumnValue(row, column);
      const maxWidth = columnWidths[index] - 4; // Account for padding
      const wrappedText = doc.splitTextToSize(value, maxWidth);

      // Draw each line of wrapped text
      wrappedText.forEach((line, lineIndex) => {
        const lineY = yPos + 6 + (lineIndex * (baseRowHeight - 2));
        doc.text(line, xPos + 2, lineY);
      });

      xPos += columnWidths[index];
    });
  }

  /**
   * Draws simplified table borders for multi-line support
   */
  drawTableBordersSimple(doc, columns, columnWidths, startY, endY) {
    doc.setDrawColor(...this.brandColors.border);
    doc.setLineWidth(0.1);

    const tableWidth = columnWidths.reduce((sum, width) => sum + width, 0);

    // Outer border
    doc.rect(20, startY, tableWidth, endY - startY);

    // Vertical lines between columns
    let xPos = 20;
    for (let i = 1; i < columns.length; i++) {
      xPos += columnWidths[i - 1];
      doc.line(xPos, startY, xPos, endY);
    }
  }

  /**
   * Adds empty state message
   */
  addEmptyState(doc, startY) {
    doc.setFontSize(12);
    doc.setTextColor(...this.brandColors.error);
    doc.text('No data found to export.', 20, startY + 20);
  }

  /**
   * Calculates optimal column widths
   */
  calculateColumnWidths(columns, totalWidth) {
    const weights = columns.map(col => col.width || 1);
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);

    return weights.map(weight => (weight / totalWeight) * totalWidth);
  }

  /**
   * Gets column value from row data
   */
  getColumnValue(row, column) {
    if (column.formatter && typeof column.formatter === 'function') {
      return column.formatter(row);
    }

    const value = column.key.split('.').reduce((obj, key) => obj?.[key], row);
    return value !== undefined && value !== null ? String(value) : 'N/A';
  }

  /**
   * Truncates text to fit column width
   */
  truncateText(text, maxWidth) {
    const maxLength = Math.floor(maxWidth / 1.8); // Improved character limit calculation
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength - 3) + '...';
  }

  /**
   * Sanitizes filename for download
   */
  sanitizeFilename(filename) {
    return filename.replace(/[^a-z0-9]/gi, '_').toLowerCase();
  }

  /**
   * Creates data analysis report PDF
   * @param {Object} analysisData - Analysis data including KPIs, charts data, and device details
   * @param {Array} devices - Array of device objects
   * @param {Object} filters - Applied filters
   */
  async exportDataAnalysisReport(analysisData, devices = [], filters = {}) {
    try {
      const { jsPDF } = await import('jspdf');
      const doc = new jsPDF('l', 'mm', 'a4'); // Landscape for better chart display

      let yPos = 25;

      // Title and Header
      doc.setFontSize(24);
      doc.setTextColor(...this.brandColors.primary);
      doc.text('Data Analysis Report', 20, yPos);
      yPos += 18;

      // Subtitle
      doc.setFontSize(16);
      doc.setTextColor(0, 0, 0);
      doc.text('Device Management System Analytics', 20, yPos);
      yPos += 12;

      // Date and info
      doc.setFontSize(11);
      doc.setTextColor(...this.brandColors.secondary);
      doc.text(`Generated on: ${new Date().toLocaleDateString('en-GB')} at ${new Date().toLocaleTimeString('en-GB')}`, 20, yPos);
      yPos += 6;

      if (filters.company) {
        doc.text(`Company: ${filters.company}`, 20, yPos);
        yPos += 6;
      }

      doc.text(`Total Devices Analyzed: ${devices.length}`, 20, yPos);
      yPos += 15;

      // Executive Summary Section as Table
      doc.setFontSize(16);
      doc.setTextColor(...this.brandColors.primary);
      doc.text('Executive Summary', 20, yPos);
      yPos += 12;

      const kpiMetrics = analysisData.kpiMetrics || {};

      const summaryColumns = [
        { key: 'category', header: 'Category', width: 1.5 },
        { key: 'status', header: 'Current Status', width: 4.5 }
      ];

      const summaryData = [
        {
          category: 'Device Upgrade Status',
          status: `${kpiMetrics.upgradePercentage || 0}% of devices are up to specification and meet current performance standards`
        },
        {
          category: 'Operating System Distribution',
          status: `Windows ${kpiMetrics.osDistribution?.Windows || 0}%, iOS ${kpiMetrics.osDistribution?.iOS || 0}%, Android ${kpiMetrics.osDistribution?.Android || 0}% - Mixed environment across platforms`
        },
        {
          category: 'Processor Performance',
          status: `${kpiMetrics.processorBelowSpec || 0}% of devices have processors below specification and require CPU upgrades`
        },
        {
          category: 'Memory Configuration',
          status: `${kpiMetrics.ramDistribution?.under8GB || 0}% under 8GB (insufficient), ${kpiMetrics.ramDistribution?.ram8GB || 0}% with 8GB (adequate), ${kpiMetrics.ramDistribution?.ram16GBPlus || 0}% with 16GB+ (optimal)`
        }
      ];

      this.addProfessionalTable(doc, summaryData, summaryColumns, yPos);
      yPos += (summaryData.length + 2) * 10 + 15;

      // Key Performance Indicators Table
      doc.setFontSize(16);
      doc.setTextColor(...this.brandColors.primary);
      doc.text('Key Performance Indicators', 20, yPos);
      yPos += 12;

      const kpiColumns = [
        { key: 'metric', header: 'Metric', width: 1.8 },
        { key: 'value', header: 'Value', width: 1.2 },
        { key: 'details', header: 'Details', width: 3 }
      ];

      const kpiData = [
        {
          metric: 'Device Upgrade Status',
          value: `${kpiMetrics.upgradePercentage || 0}%`,
          details: `${kpiMetrics.upgradeStats?.upgraded || 0} of ${kpiMetrics.upgradeStats?.total || 0} devices meet specifications`
        },
        {
          metric: 'Processor Performance',
          value: `${kpiMetrics.processorBelowSpec || 0}% below spec`,
          details: `${kpiMetrics.processorStats?.belowSpec || 0} devices need CPU upgrade`
        },
        {
          metric: 'Memory Adequacy',
          value: `${kpiMetrics.ramDistribution?.under8GB || 0}% insufficient`,
          details: `Devices with less than 8GB RAM need memory upgrade`
        },
        {
          metric: 'OS Distribution',
          value: 'Mixed environment',
          details: `Windows: ${kpiMetrics.osDistribution?.Windows || 0}%, iOS: ${kpiMetrics.osDistribution?.iOS || 0}%, Android: ${kpiMetrics.osDistribution?.Android || 0}%`
        }
      ];

      this.addProfessionalTable(doc, kpiData, kpiColumns, yPos);
      yPos += (kpiData.length + 2) * 10 + 10;

      // Device Status Distribution
      if (yPos > 150) {
        doc.addPage();
        yPos = 20;
      }

      doc.setFontSize(16);
      doc.setTextColor(...this.brandColors.primary);
      doc.text('Device Status Analysis', 20, yPos);
      yPos += 12;

      if (devices.length > 0) {
        const statusCounts = { Working: 0, 'Needs Repair': 0, 'Broken': 0 };
        devices.forEach(device => {
          if (statusCounts.hasOwnProperty(device.status)) {
            statusCounts[device.status]++;
          }
        });

        const statusColumns = [
          { key: 'status', header: 'Status', width: 1.2 },
          { key: 'count', header: 'Count', width: 0.8 },
          { key: 'percentage', header: 'Percentage', width: 1 },
          { key: 'recommendation', header: 'Recommendation', width: 3 }
        ];

        const statusData = Object.entries(statusCounts).map(([status, count]) => {
          const percentage = devices.length > 0 ? ((count / devices.length) * 100).toFixed(1) : '0.0';
          let recommendation = 'Monitor status';

          if (status === 'Broken') recommendation = 'Immediate replacement required';
          else if (status === 'Needs Repair') recommendation = 'Schedule maintenance';
          else if (status === 'Working') recommendation = 'Continue monitoring';

          return {
            status,
            count: count.toString(),
            percentage: `${percentage}%`,
            recommendation
          };
        });

        this.addProfessionalTable(doc, statusData, statusColumns, yPos);
        yPos += (statusData.length + 2) * 10 + 10;
      }

      // Device Type Distribution
      if (yPos > 140) {
        doc.addPage();
        yPos = 20;
      }

      doc.setFontSize(16);
      doc.setTextColor(...this.brandColors.primary);
      doc.text('Device Type Distribution', 20, yPos);
      yPos += 12;

      if (devices.length > 0) {
        const typeCounts = { Laptop: 0, Desktop: 0, Tablet: 0, Phone: 0 };
        devices.forEach(device => {
          if (typeCounts.hasOwnProperty(device.deviceType)) {
            typeCounts[device.deviceType]++;
          }
        });

        const typeColumns = [
          { key: 'type', header: 'Device Type', width: 1.2 },
          { key: 'count', header: 'Count', width: 0.8 },
          { key: 'percentage', header: 'Percentage', width: 1 },
          { key: 'businessImpact', header: 'Business Impact', width: 3 }
        ];

        const typeData = Object.entries(typeCounts)
          .filter(([type, count]) => count > 0)
          .map(([type, count]) => {
            const percentage = devices.length > 0 ? ((count / devices.length) * 100).toFixed(1) : '0.0';
            let businessImpact = 'Standard productivity';

            if (type === 'Laptop') businessImpact = 'High mobility, flexible work';
            else if (type === 'Desktop') businessImpact = 'Office-based, high performance';
            else if (type === 'Tablet') businessImpact = 'Presentations, mobile tasks';
            else if (type === 'Phone') businessImpact = 'Communication, mobile access';

            return {
              type,
              count: count.toString(),
              percentage: `${percentage}%`,
              businessImpact
            };
          });

        this.addProfessionalTable(doc, typeData, typeColumns, yPos);
        yPos += (typeData.length + 2) * 10 + 10;
      }

      // Device Inventory Details (First 15 devices)
      if (devices.length > 0) {
        if (yPos > 100) {
          doc.addPage();
          yPos = 20;
        }

        doc.setFontSize(16);
        doc.setTextColor(...this.brandColors.primary);
        doc.text('Device Inventory Sample', 20, yPos);
        yPos += 12;

        const inventoryColumns = [
          { key: 'staffName', header: 'Staff Name', width: 1.5 },
          { key: 'deviceModel', header: 'Device Model', width: 2.5 },
          { key: 'deviceType', header: 'Type', width: 0.8 },
          { key: 'operatingSystem', header: 'OS', width: 1.5 },
          { key: 'ram', header: 'RAM', width: 0.7 },
          { key: 'status', header: 'Status', width: 1 }
        ];

        const inventoryData = devices.slice(0, 15).map(device => ({
          staffName: device.staffName,
          deviceModel: device.deviceModel,
          deviceType: device.deviceType,
          operatingSystem: device.operatingSystem,
          ram: device.ram,
          status: device.status
        }));

        this.addProfessionalTable(doc, inventoryData, inventoryColumns, yPos);

        if (devices.length > 15) {
          yPos += (inventoryData.length + 2) * 10 + 15;
          doc.setFontSize(11);
          doc.setTextColor(...this.brandColors.secondary);
          doc.text(`... and ${devices.length - 15} more devices (see full inventory for complete list)`, 20, yPos);
        }
      }

      // Recommendations Section
      doc.addPage();
      yPos = 20;

      doc.setFontSize(18);
      doc.setTextColor(...this.brandColors.primary);
      doc.text('Recommendations & Action Items', 20, yPos);
      yPos += 15;

      const recommendations = [
        {
          priority: 'High',
          item: 'Device Upgrades',
          description: `${kpiMetrics.processorStats?.belowSpec || 0} devices require CPU/hardware upgrades for optimal performance`,
          timeline: 'Next 3 months'
        },
        {
          priority: 'Medium',
          item: 'Memory Expansion',
          description: `${Math.round((kpiMetrics.ramDistribution?.under8GB || 0) * devices.length / 100)} devices need RAM upgrades to 8GB minimum`,
          timeline: 'Next 6 months'
        },
        {
          priority: 'Medium',
          item: 'OS Updates',
          description: 'Ensure all operating systems are running latest stable versions for security',
          timeline: 'Ongoing'
        },
        {
          priority: 'Low',
          item: 'Device Standardization',
          description: 'Consider standardizing device types and configurations for easier management',
          timeline: 'Next year'
        }
      ];

      const recColumns = [
        { key: 'priority', header: 'Priority', width: 0.8 },
        { key: 'item', header: 'Action Item', width: 1.2 },
        { key: 'description', header: 'Description', width: 4 },
        { key: 'timeline', header: 'Timeline', width: 1 }
      ];

      this.addProfessionalTable(doc, recommendations, recColumns, yPos);

      // Footer on all pages
      const totalPages = doc.getNumberOfPages();
      for (let i = 1; i <= totalPages; i++) {
        doc.setPage(i);
        doc.setFontSize(9);
        doc.setTextColor(...this.brandColors.secondary);
        doc.text(`Page ${i} of ${totalPages}`, 250, 200);
        doc.text('Device Management System - Data Analysis Report - Confidential', 20, 200);
      }

      // Save the PDF
      const filename = this.generateFilename('data_analysis_report', filters);
      doc.save(filename);

      return true;
    } catch (error) {
      console.error('Data analysis PDF generation failed:', error);
      return false;
    }
  }

  /**
   * Generates standardized filename
   */
  generateFilename(prefix, filters = {}) {
    const today = new Date();
    const dateStr = `${today.getDate().toString().padStart(2, '0')}${(today.getMonth() + 1).toString().padStart(2, '0')}${today.getFullYear()}`;
    return `${prefix}_${dateStr}.pdf`;
  }
}

export const pdfService = new PDFService();
export default pdfService;